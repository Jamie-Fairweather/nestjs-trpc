---
title: "NestJS-tRPC Documentation - App Router Host"
---

import { Callout } from 'nextra/components';
import Link from 'next/link';

# App Router Host

## Overview

The `AppRouterHost` class is a crucial part of the NestJS-tRPC adapter that provides access to your tRPC router. It serves as a bridge between your NestJS application and the tRPC router, allowing you to access the router from anywhere in your application.

## Basic Usage

The `AppRouterHost` is provided by the `TRPCModule` and can be injected into any provider or controller:

```typescript
import { Injectable } from '@nestjs/common';
import { AppRouterHost } from 'nestjs-trpc';

@Injectable()
export class MyService {
  constructor(private readonly appRouterHost: AppRouterHost) {}

  someMethod() {
    const router = this.appRouterHost.appRouter;
    // Use the router...
  }
}
```

## Initialization Timing

The router is created during the initialization of the `TRPCModule`, specifically within its `onModuleInit` lifecycle hook. This means that if you try to access the router before the module has completed initialization, you may encounter an error.

<Callout type="warning">
  In NestJS, there is no guaranteed order of module initialization. If you have a controller or provider that implements `OnModuleInit` and tries to access the router, it might run before the `TRPCModule` has created the router.
</Callout>

## Safe Router Access (Added in v1.7.6)

To handle the initialization timing issue, version 1.7.6 introduces new methods for safely accessing the router:

### `isRouterReady()`

Returns a boolean indicating whether the router has been initialized:

```typescript
if (appRouterHost.isRouterReady()) {
  // Safe to access the router
  const router = appRouterHost.appRouter;
}
```

### `getRouterSafe()`

Returns the router if it's ready, or `undefined` if it's not yet initialized:

```typescript
const router = appRouterHost.getRouterSafe();
if (router) {
  // Router is available, use it
} else {
  // Router not ready yet, handle accordingly
}
```

## Example: Safe Usage in Controllers

Here's an example of how to safely use the router in a controller that implements `OnModuleInit`:

```typescript
import { Controller, OnModuleInit } from '@nestjs/common';
import { AppRouterHost } from 'nestjs-trpc';

@Controller('my-controller')
export class MyController implements OnModuleInit {
  private router?: AnyRouter;

  constructor(private readonly appRouterHost: AppRouterHost) {}

  onModuleInit() {
    // Safe way to get the router without throwing errors
    this.router = this.appRouterHost.getRouterSafe();
  }

  handleRequest() {
    // Check if router is available before using it
    if (!this.router) {
      // Try to get it again, it might be ready now
      if (this.appRouterHost.isRouterReady()) {
        this.router = this.appRouterHost.appRouter;
      } else {
        // Router still not ready
        return { error: 'Router not ready yet' };
      }
    }
    
    // Now safe to use the router
    return { success: true };
  }
}
```

## Error Handling with try/catch

If you prefer, you can also use a try/catch approach to handle the router access:

```typescript
try {
  const router = this.appRouterHost.appRouter;
  // Use the router...
} catch (error) {
  // Handle the case where the router isn't ready
  console.log('Router not ready yet:', error.message);
}
```

This pattern is useful for gradually migrating existing code that directly accesses the router. 